"""
This module contains an example of how the ``MultiAttentionStudent`` model can be trained to predict the
aq. solubility of molecules and also produce multi-channel explanations in the process.

This module is structured as a ``pycomex`` computational experiment module. Check out the ``pycomex``
project to see the benefits this provides:

https://github.com/the16thpythonist/pycomex

You can simply execute this module and the progress of the experiment execution and the model training
will be logged to the console. Additionally all experiment artifacts will be saved into a new folder, which
will automatically created in the current working directory. This artifact folder will contain the PDF
plots, the raw results in form of a JSON file and an analysis.py file which can be modified an executed
to change the plotting of the results.
"""
import os
import sys
import pathlib
import random
from typing import List

import numpy as np
import tensorflow as tf
import tensorflow_addons as tfa
import tensorflow.keras as ks
import matplotlib.pyplot as plt
from imageio.v2 import imread
from matplotlib.backends.backend_pdf import PdfPages
from pycomex.experiment import Experiment

from graph_attention_student.util import DATASETS_FOLDER, PATH
from graph_attention_student.data import load_eye_tracking_dataset
from graph_attention_student.data import process_graph_dataset
from graph_attention_student.layers import StaticMultiplicationEmbedding
from graph_attention_student.models import MultiAttentionStudent
from graph_attention_student.training import LogProgressCallback
from graph_attention_student.training import NoLoss
from graph_attention_student.visualization import plot_node_importances, plot_edge_importances

DATASET = 'solubility'
DATASETS = {
    'rb-motifs': {
        'DATASET_PATH': os.path.join(DATASETS_FOLDER, 'rb_dual_motifs'),
        'UNITS': [3, 3, 3],
        'IMPORTANCE_UNITS': [3],
        'EPOCHS': 100,
        'VALUE_KEY': 'value',
        'BINNING': {
            0: (-5, 0),
            1: (0, +5)
        }
    },
    'solubility': {
        'DATASET_PATH': os.path.join(DATASETS_FOLDER, 'solubility_aqsoldb'),
        'UNITS': [12, 8, 6],
        'IMPORTANCE_UNITS': [5],
        'EPOCHS': 200,
        'VALUE_KEY': 'value',
        'BINNING': {
            0: (-11, -3),
            1: (-3, +3),
        }
    },
    'quantum-optics': {
        'DATASET_PATH': os.path.join(DATASETS_FOLDER, 'quantum_optics'),
        'UNITS': [10, 8, 6],
        'IMPORTANCE_UNITS': [3],
        'EPOCHS': 100,
        'VALUE_KEY': 'value',
        'BINNING': {
            0: (2, 4),
            1: (7, 9)
        }
    }
}
BINNING = None

# Dataset related
DATASET_PATH = os.path.join(DATASETS_FOLDER, 'quantum_optics')
TEST_RATIO = 0.1
NUM_EXAMPLES = 50
VALUE_KEY = 'value'

# Model related
IMPORTANCE_CHANNELS = [2, 9]
UNITS = [3, 2, 1]
IMPORTANCE_UNITS = []
FINAL_UNITS = []
DROPOUT_RATE = 0.0
FINAL_DROPOUT_RATE = 0.0
SPARSITY_FACTOR = 0.0
IMPORTANCE_FACTOR = 0.0
EXCLUSIVITY_FACTOR = 0.0
METRIC_KEY = 'categorical_accuracy'

# Training related
LEARNING_RATE = 0.01
BATCH_SIZE = 512
EPOCHS = 100

for key, value in DATASETS[DATASET].items():
    globals()[key] = value

NUM_BINS: int = len(BINNING)
NUM_CHANNELS = len(BINNING)
BIN_LIMITS = list(BINNING.values())

def custom_sigmoid(x):
    return ks.backend.sigmoid(20 * x - 10)

NAMESPACE = 'classification'
BASE_PATH = os.getcwd()
DEBUG = True
with Experiment(namespace=NAMESPACE, base_path=BASE_PATH, glob=globals()) as e:
    e.prepare()

    # ~ Loading dataset

    # This function loads a "eye tracking dataset": This simply means that the dataset is structured in a
    # special way, namely like this: The dataset consists of an entire folder, where every element has two
    # files. One is a JSON file, which actually contains the graph structure that represents the element as
    # well as the prediction target etc. And then there is also an image file for each element which is a
    # visual representation of the graph. We can later use this to visualize the explanations generated by
    # the model.
    eye_tracking_dataset: List[dict] = load_eye_tracking_dataset(DATASET_PATH)
    dataset_size = len(eye_tracking_dataset)
    e.info(f'loaded dataset with {dataset_size} elements')

    dataset_indices = list(range(dataset_size))
    test_indices = random.sample(dataset_indices, k=int(TEST_RATIO * dataset_size))
    example_indices = random.sample(test_indices, k=NUM_EXAMPLES)
    train_indices = [i for i in dataset_indices if i not in test_indices]
    e['test_indices'] = test_indices
    e['example_indices'] = example_indices
    e.info(f'randomly chose {len(test_indices)} test indices')

    # "eye_tracking_dataset" at this point is only a list of dictionaries which contain the metadata info
    # for each respective elements. This now has to be turned into the appropriate tensors to be used by
    # the model.
    dataset = []
    for data in eye_tracking_dataset:
        g = data['metadata']['graph']

        value = data['metadata'][VALUE_KEY]
        g['graph_labels'] = np.zeros(shape=(NUM_BINS, ))
        for index, limits in BINNING.items():
            if limits[0] <= value < limits[1]:
                g['graph_labels'][index] = 1

        data['metadata']['one_hot'] = g['graph_labels']
        g['node_importances'] = np.zeros(shape=len(g['node_indices']))
        g['edge_importances'] = np.zeros(shape=len(g['edge_indices']))
        dataset.append(g)

    x_train, y_train, x_test, y_test = process_graph_dataset(dataset, test_indices)

    model: ks.models.Model = MultiAttentionStudent(
        units=UNITS,
        dropout_rate=DROPOUT_RATE,
        sparsity_factor=SPARSITY_FACTOR,
        exclusivity_factor=EXCLUSIVITY_FACTOR,
        importance_factor=IMPORTANCE_FACTOR,
        importance_units=IMPORTANCE_UNITS,
        importance_channels=NUM_CHANNELS,
        use_bias=False,
        final_units=FINAL_UNITS,
        final_dropout_rate=FINAL_DROPOUT_RATE,
        final_activation=custom_sigmoid,
    )
    model.output_blocked = True
    model.compile(
        loss=[
            # ks.losses.CategoricalCrossentropy(),
            ks.losses.BinaryCrossentropy(),
            NoLoss(),
            NoLoss()
        ],
        loss_weights=[
            1,
            0,
            0
        ],
        metrics=[
            ks.metrics.CategoricalAccuracy(),
            ks.metrics.MeanAbsoluteError(),
            #tfa.metrics.RSquare(),
        ],
        optimizer=ks.optimizers.Adam(learning_rate=LEARNING_RATE),
        run_eagerly=False
    )

    e.info('starting to train the model...')
    history = model.fit(
        x_train,
        y_train,
        batch_size=BATCH_SIZE,
        epochs=EPOCHS,
        validation_data=(x_test, y_test),
        validation_freq=1,
        callbacks=LogProgressCallback(
            logger=e.logger,
            epoch_step=25,
            identifier=f'val_output_1_{METRIC_KEY}'
        ),
        verbose=0
    )
    e['history'] = history.history
    e['epochs'] = list(range(EPOCHS))

    # Running the whole test set through the model and saving the predictions
    for index in test_indices:
        g = dataset[index]
        prediction, node_importances, edge_importances = model.predict_single([
            g['node_attributes'],
            g['edge_attributes'],
            g['edge_indices']
        ])
        e[f'predictions/{index}/prediction'] = prediction
        e[f'predictions/{index}/node_importances'] = node_importances
        e[f'predictions/{index}/edge_importances'] = edge_importances

    # All of this code will automatically also be copied into the "analysis.py" file in the results folder
    # which can then also be executed again independently.
    with e.analysis:

        # visualizing the prediction metric over training
        fig, (ax_pred) = plt.subplots(ncols=1, nrows=1, figsize=(8, 8))
        ax_pred.set_title('Main Metric over Training Epochs')
        ax_pred.set_xlabel('Epochs')
        ax_pred.set_ylabel('ACC')
        ax_pred.set_ylim([0, 1.1])
        ax_pred.plot(e['epochs'], e[f'history/val_output_1_{METRIC_KEY}'], c='blue', label='test')
        ax_pred.plot(e['epochs'], e[f'history/output_1_{METRIC_KEY}'], c='blue', alpha=0.5,
                     label='train')
        ax_pred.legend()
        e.commit_fig('prediction_over_epochs.pdf', fig)

        # visualizing the explanations
        explanations_path = os.path.join(e.path, 'explanations.pdf')
        with PdfPages(explanations_path) as pdf:

            for index in e['example_indices']:
                data = eye_tracking_dataset[index]
                g = data['metadata']['graph']

                fig, rows = plt.subplots(nrows=1, ncols=NUM_CHANNELS, figsize=(8*NUM_CHANNELS, 8),
                                         squeeze=False)
                rounded_prediction = [round(v, 2) for v in e["predictions"][str(index)]["prediction"]]
                title = (f'Ground Truth: ' + f'{data["metadata"][VALUE_KEY]:.3f} ' + ' - ' +
                         f'Binned: ' + str(data['metadata']['one_hot']) + ' - ' +
                         f'Prediction: ' + str(rounded_prediction))
                fig.suptitle(title)
                image = np.asarray(imread(data['image_path']))

                for ax_index, ax in enumerate(rows[0]):
                    ax.set_title(f'Channel {ax_index}: {str(BIN_LIMITS[ax_index])}')
                    ax.imshow(image, extent=(0, image.shape[0], 0, image.shape[1]))

                    node_importances = np.array(e[f'predictions/{index}/node_importances'])
                    plot_node_importances(
                        g=g,
                        ax=ax,
                        vmax=np.max(node_importances[:, ax_index]),
                        #vmax=1.01,
                        node_importances=node_importances[:, ax_index],
                        node_coordinates=data['graph']['node_coordinates']
                    )

                    edge_importances = np.array(e[f'predictions/{index}/edge_importances'])
                    plot_edge_importances(
                        g=g,
                        ax=ax,
                        vmax=np.max(edge_importances[:, ax_index]),
                        #vmax=1.01,
                        edge_importances=edge_importances[:, ax_index],
                        node_coordinates=data['graph']['node_coordinates']
                    )

                pdf.savefig(fig)
                plt.close(fig)
